WEBVTT

1
00:00:01.770 --> 00:00:05.810
We've seen how dynamic
typing in JavaScript lets

2
00:00:05.810 --> 00:00:09.330
us do some interesting things and
can also be a little dangerous.

3
00:00:10.530 --> 00:00:12.620
But what if you have a variable and

4
00:00:12.620 --> 00:00:15.330
you want to know what type it is,
programmatically?

5
00:00:15.330 --> 00:00:19.680
Well, JavaScript does come with

6
00:00:19.680 --> 00:00:23.880
some utilities to help us with that,
but they aren't perfect.

7
00:00:23.880 --> 00:00:28.770
This is typeof, instanceof, and
figuring out what something is.

8
00:00:30.000 --> 00:00:34.950
I've gone ahead and pre-filled our app.js
file with some variables of different

9
00:00:34.950 --> 00:00:42.800
types, and I'm using the typeof
keyword and the instanceof keyword.

10
00:00:42.800 --> 00:00:46.660
For starters the typeof tells
us what you would expect.

11
00:00:46.660 --> 00:00:49.570
What type of thing is this.

12
00:00:49.570 --> 00:00:54.810
So, for example, I have a variable
set to a numeric primitive,

13
00:00:54.810 --> 00:01:00.935
a number primitive, and the first thing
that I see printed is the word number.

14
00:01:00.935 --> 00:01:02.295
Notice that's lower case n.

15
00:01:03.455 --> 00:01:08.365
I'm not using the function
constructor Number with a capital N,

16
00:01:08.365 --> 00:01:10.775
which we generally want to avoid.

17
00:01:10.775 --> 00:01:15.065
So I get that primitive type number,
with a lowercase n.

18
00:01:15.065 --> 00:01:21.020
So I can check and see if my variable is
a number, this typeof returns a string.

19
00:01:21.020 --> 00:01:25.330
It's an operator, which means it's
a function that takes a parameter and

20
00:01:25.330 --> 00:01:26.470
it returns a string.

21
00:01:27.760 --> 00:01:31.250
So the string that it returns is number,
in this case.

22
00:01:31.250 --> 00:01:35.390
Here I made a string, so typeof space and

23
00:01:35.390 --> 00:01:42.420
then the variable I'm checking
returns the string, string.

24
00:01:42.420 --> 00:01:46.500
I have an empty object, this could have
properties and methods, it doesn't matter.

25
00:01:46.500 --> 00:01:52.990
When I look at typeof and pass this object
to it, I get the word, the string, object.

26
00:01:54.170 --> 00:01:56.150
Here's one that's a little weird.

27
00:01:56.150 --> 00:01:58.620
Arrays are objects.

28
00:01:58.620 --> 00:02:02.890
And so when I pass to it an array,
an empty array,

29
00:02:02.890 --> 00:02:08.320
typeof, it gives me back also object.

30
00:02:08.320 --> 00:02:10.150
That's not so useful.

31
00:02:10.150 --> 00:02:12.560
There's a couple of ways around this.

32
00:02:12.560 --> 00:02:16.990
One of them is to use both
the prototype concept and

33
00:02:16.990 --> 00:02:19.420
the concept of .call,
which you've already seen.

34
00:02:20.940 --> 00:02:28.330
When I do the typeof on the array,
I get the string, object.

35
00:02:29.600 --> 00:02:31.665
If I was to try, let's say,

36
00:02:31.665 --> 00:02:37.950
console.log(d.toString()); maybe
that would help me.

37
00:02:39.340 --> 00:02:44.500
What i get is just an empty string,
because

38
00:02:44.500 --> 00:02:48.860
it actually tries to take the contents
of the array and convert it to a string.

39
00:02:48.860 --> 00:02:51.060
So that's not helpful either.

40
00:02:51.060 --> 00:02:57.330
However, on that base object,
called object, that I'm looking at,

41
00:02:57.330 --> 00:03:02.550
there is a two string property
on its prototype, on this

42
00:03:03.620 --> 00:03:09.880
function constructor's prototype,
which is the base object toString.

43
00:03:09.880 --> 00:03:15.930
And then instead of acting on this Object
function constructor of the prototype,

44
00:03:15.930 --> 00:03:20.190
I'm doing .call, which as you know means

45
00:03:20.190 --> 00:03:24.668
invoke this function but tell it
what this variable should point to.

46
00:03:24.668 --> 00:03:30.130
So since toString uses the this
variable to output its value,

47
00:03:30.130 --> 00:03:32.230
I'm saying take my array and

48
00:03:32.230 --> 00:03:38.300
call this toString on it deeper
down in the prototype chain.

49
00:03:38.300 --> 00:03:41.910
And that little trick gets me this string.

50
00:03:41.910 --> 00:03:46.430
And this is a string, it's object and

51
00:03:46.430 --> 00:03:49.990
then the word array with
some brackets around it.

52
00:03:49.990 --> 00:03:53.040
So at least I can tell that
this is an array this way.

53
00:03:54.740 --> 00:03:58.560
Then I have a Person function constructor.

54
00:03:58.560 --> 00:04:01.530
I give it a capital P and
I'm not returning anything.

55
00:04:02.540 --> 00:04:05.810
And so
I set a variable equal to new Person.

56
00:04:06.980 --> 00:04:13.140
And let's see,
the typeof e is also an object.

57
00:04:13.140 --> 00:04:14.220
That's expected.

58
00:04:14.220 --> 00:04:15.300
This is just an object.

59
00:04:16.790 --> 00:04:20.310
This other keyword called instanceof,
though, what it does,

60
00:04:20.310 --> 00:04:24.100
it tells me if any object is
down the prototype chain.

61
00:04:24.100 --> 00:04:28.150
If anywhere down that whole prototype
chain of going proto, to proto,

62
00:04:28.150 --> 00:04:30.780
to proto, I find this type of object.

63
00:04:31.940 --> 00:04:36.290
If I do then this first parameter
is an instance of that one.

64
00:04:36.290 --> 00:04:39.300
So e should return true because it's

65
00:04:39.300 --> 00:04:43.110
an instance of person because we can find
the person down the prototype chain.

66
00:04:44.210 --> 00:04:45.450
And it does come back true.

67
00:04:47.050 --> 00:04:51.280
Lastl,y we have typeof undefined and
typeof null.

68
00:04:51.280 --> 00:04:56.630
Well, undefined isn't anything,
so its type is undefined.

69
00:04:56.630 --> 00:04:57.780
So that kind of makes sense.

70
00:04:58.840 --> 00:05:02.800
One last thing that's been a bug
in JavaScript since forever,

71
00:05:02.800 --> 00:05:07.575
a long time, so much so
that there are libraries and

72
00:05:07.575 --> 00:05:13.045
a lot of code that rely on it being so,
so they've never fixed it.

73
00:05:13.045 --> 00:05:18.225
If you try to do typeof and something
is null, you'll end up with an object.

74
00:05:18.225 --> 00:05:22.175
I know that's kind of terrible,
but it's a bug and

75
00:05:22.175 --> 00:05:25.550
it's been around too
long to fix in some ways.

76
00:05:25.550 --> 00:05:32.500
So typeof, which is an operator that
accepts a parameter, but it's essentially

77
00:05:32.500 --> 00:05:38.630
a function returning a string, will tell
you under most cases what something is.

78
00:05:38.630 --> 00:05:41.754
An instanceof,
if you dealing with object chains,

79
00:05:41.754 --> 00:05:45.170
will tell you what something
has in its prototype chain.

80
00:05:46.310 --> 00:05:50.250
And these can be useful under certain
circumstances when you need to tell what

81
00:05:50.250 --> 00:05:53.820
something is that's being passed in
if you don't know ahead of time or

82
00:05:53.820 --> 00:05:55.070
it might be multiple types.

83
00:05:56.130 --> 00:05:58.490
Oh, and one more thing.

84
00:05:58.490 --> 00:06:04.450
Let's set a variable z equal
to just an empty function.

85
00:06:05.740 --> 00:06:11.428
What do you think I'll get when
i do console.log(typeof z)?

86
00:06:11.428 --> 00:06:12.712
Lets refresh.

87
00:06:12.712 --> 00:06:15.380
I get the string function.

88
00:06:16.630 --> 00:06:21.670
Remember, I can check the type of a
variable to see if it's a function because

89
00:06:21.670 --> 00:06:26.040
functions in JavaScript are objects.

90
00:06:26.040 --> 00:06:29.860
So since it's a first class function,
it's really an object.

91
00:06:29.860 --> 00:06:33.050
I can also see if
a variable is a function.

92
00:06:33.050 --> 00:06:33.570
Pretty useful.

93
00:06:34.920 --> 00:06:37.940
All right, so
that's typeof and instanceof.

94
00:06:37.940 --> 00:06:39.580
Try these out for yourself.

95
00:06:39.580 --> 00:06:40.650
See what kind of results you get.

