WEBVTT

1
00:00:01.850 --> 00:00:05.830
So we've seen that function constructors
can be used to set up properties and

2
00:00:05.830 --> 00:00:11.210
methods on new objects, but
how do we set the prototype,

3
00:00:11.210 --> 00:00:14.280
the other important part of
creating objects in JavaScript?

4
00:00:15.360 --> 00:00:16.540
Let's take a look.

5
00:00:16.540 --> 00:00:18.830
So here's our code from the last lesson.

6
00:00:18.830 --> 00:00:22.770
And the question now is,
how do we set the prototype?

7
00:00:22.770 --> 00:00:26.110
Well there's good news.

8
00:00:26.110 --> 00:00:30.830
When you use a function constructor,
it already set the prototype for you.

9
00:00:32.870 --> 00:00:34.210
Let's go take a look.

10
00:00:35.370 --> 00:00:36.379
I'll refresh this.

11
00:00:37.380 --> 00:00:42.580
Notice that we have our
output of our two objects.

12
00:00:42.580 --> 00:00:48.311
But if I did john._proto_,
which works here inside Chrome,

13
00:00:48.311 --> 00:00:54.690
I'll see that it's some kind of
special Person object that's empty.

14
00:00:56.130 --> 00:00:58.400
It's an empty object, but
where did it come from?

15
00:01:00.340 --> 00:01:04.630
Well, any time you create
a function object,

16
00:01:04.630 --> 00:01:09.385
remember how we said that it
has certain special properties?

17
00:01:09.385 --> 00:01:11.775
Like the name and the code?

18
00:01:11.775 --> 00:01:15.245
Well, there's another property
that all functions get

19
00:01:16.435 --> 00:01:21.210
that is actually completely visible
to you and that you can and

20
00:01:21.210 --> 00:01:26.755
should use when you're using
a function as a function constructor.

21
00:01:26.755 --> 00:01:32.750
So remember, our function is an object,
and JavaScript functions are objects.

22
00:01:32.750 --> 00:01:37.290
Some properties, we don't really
think about that much, like name.

23
00:01:37.290 --> 00:01:39.370
A function can be anonymous.

24
00:01:39.370 --> 00:01:42.630
We've learned that a function
has a special code property

25
00:01:42.630 --> 00:01:46.782
that holds the code that gets
executed when you invoke it.

26
00:01:46.782 --> 00:01:48.800
It's invokable.

27
00:01:48.800 --> 00:01:52.920
And all functions, every function,

28
00:01:52.920 --> 00:01:58.569
every function in JavaScript you've ever
written in your life, has a prototype

29
00:01:58.569 --> 00:02:03.870
property that starts off its
life as an empty object,

30
00:02:05.460 --> 00:02:10.270
and unless you're using the function as
a function constructor, it just hangs out.

31
00:02:10.270 --> 00:02:11.070
It's never used.

32
00:02:12.390 --> 00:02:15.960
But as soon as you use the new
operator to invoke your function,

33
00:02:17.070 --> 00:02:18.570
then it means something.

34
00:02:20.070 --> 00:02:20.870
It sits there.

35
00:02:20.870 --> 00:02:27.710
It lives only for when you're using
a function as a function constructor.

36
00:02:27.710 --> 00:02:30.280
For when you're using a function
specifically to build

37
00:02:30.280 --> 00:02:35.410
objects in this special way,
the prototype property is used.

38
00:02:35.410 --> 00:02:41.410
And it's a confusing name, because if I
see something dot prototype, I think,

39
00:02:41.410 --> 00:02:47.220
oh, I'm setting or accessing
the prototype of this object, but no.

40
00:02:47.220 --> 00:02:50.810
Remember we already saw that in some
cases you can use underscore underscore

41
00:02:50.810 --> 00:02:55.770
proto underscore underscore to
get access to the prototype.

42
00:02:55.770 --> 00:03:01.620
The prototype property on a function
is not the prototype of the function.

43
00:03:03.330 --> 00:03:06.800
It's the prototype of any objects created

44
00:03:08.040 --> 00:03:10.750
if you're using the function
as a function constructor.

45
00:03:10.750 --> 00:03:14.362
All right, let's look at that.

46
00:03:14.362 --> 00:03:18.740
All functions,
every function you create in JavaScript,

47
00:03:18.740 --> 00:03:22.070
gets this special property, .prototype.

48
00:03:22.070 --> 00:03:22.680
There it is.

49
00:03:23.730 --> 00:03:25.290
All right.
So what is it?

50
00:03:25.290 --> 00:03:31.200
It starts its life as an empty object,
and it's always there.

51
00:03:31.200 --> 00:03:33.100
And you can add on to it.

52
00:03:33.100 --> 00:03:38.170
So let's say I add a getFullName property.

53
00:03:38.170 --> 00:03:40.950
Actually a method in this
case cuz it's a function.

54
00:03:42.140 --> 00:03:43.600
And we've already done this.

55
00:03:43.600 --> 00:03:50.750
Return this.firstname + this.lastname
just as a simple example.

56
00:03:52.130 --> 00:03:54.330
All right.
So here's what's happening.

57
00:03:54.330 --> 00:03:59.570
Remember we said the prototype
chain is that every

58
00:03:59.570 --> 00:04:04.610
object has this special property
that points to another object

59
00:04:04.610 --> 00:04:08.340
that is its prototype so it looks for
properties and methods down that chain.

60
00:04:10.170 --> 00:04:14.300
When you call the new keyword
it creates an empty object,

61
00:04:15.970 --> 00:04:19.490
and it sets the prototype
of that empty object

62
00:04:21.100 --> 00:04:25.960
to the prototype property of
the function that you then call.

63
00:04:28.300 --> 00:04:33.370
So, any objects you create using this
function as a function constructor,

64
00:04:33.370 --> 00:04:36.670
specifically using the new keyword and
not returning a value,

65
00:04:36.670 --> 00:04:41.920
letting JavaScript automatically return
that value, means that the object

66
00:04:41.920 --> 00:04:45.810
therefore created not only
has whatever properties and

67
00:04:45.810 --> 00:04:51.478
methods you attached to it inside
the function, but it has a prototype,

68
00:04:51.478 --> 00:04:57.220
which is .prototype
property of that function.

69
00:04:57.220 --> 00:04:58.780
That's where it really gets weird.

70
00:04:58.780 --> 00:04:59.960
It's terribly named.

71
00:04:59.960 --> 00:05:02.180
I'm gonna admit it.

72
00:05:02.180 --> 00:05:08.710
This prototype property of all functions
is where the prototype chain points for

73
00:05:08.710 --> 00:05:12.775
any objects created using that
function as a constructor.

74
00:05:12.775 --> 00:05:18.397
So John points to person.prototype
as its prototype,

75
00:05:18.397 --> 00:05:23.030
as its __proto, and so does Jane.

76
00:05:23.030 --> 00:05:27.640
So they'll both get access to this
method that I just added because

77
00:05:27.640 --> 00:05:29.710
this is their prototype.

78
00:05:30.900 --> 00:05:31.460
Make sense?

79
00:05:32.980 --> 00:05:40.210
So, if I run this,
now that I've added getFullName,

80
00:05:40.210 --> 00:05:47.140
you'll see that those persons added
have the getFullName function.

81
00:05:47.140 --> 00:05:51.140
I can go john.getFullName, and it works.

82
00:05:52.320 --> 00:05:53.639
Just like we did before.

83
00:05:55.460 --> 00:05:59.390
And of course,
the neat thing being that I could add

84
00:06:00.550 --> 00:06:05.920
something to my prototype, on the fly,
later, just like we saw before

85
00:06:05.920 --> 00:06:10.350
because the prototype chain is just
looking at these objects at the moment you

86
00:06:10.350 --> 00:06:15.110
try to access any one of their methods or
properties.

87
00:06:15.110 --> 00:06:22.393
So I could add a getFormalFullName
to the prototype later,

88
00:06:22.393 --> 00:06:29.398
and then,
console.log(john.getFormalFullName.

89
00:06:32.960 --> 00:06:35.873
And because I've added it to
the prototype object already,

90
00:06:35.873 --> 00:06:38.680
when this is called it searches
down the prototype chain.

91
00:06:38.680 --> 00:06:40.130
It searches John.

92
00:06:40.130 --> 00:06:44.440
It doesn't find getformalFullName,
so it searches its proto,

93
00:06:44.440 --> 00:06:48.985
its own prototype,
which is pointing at this right here.

94
00:06:48.985 --> 00:06:52.640
Person.prototype, and
I've already added getFormalFullName.

95
00:06:52.640 --> 00:06:56.970
So it finds it down the prototype chain,
and so then calls it and

96
00:06:56.970 --> 00:06:59.930
the this keyword is set up properly.

97
00:06:59.930 --> 00:07:03.740
We've already learned that too,
and it just works.

98
00:07:05.460 --> 00:07:06.330
So think about this.

99
00:07:06.330 --> 00:07:11.530
That means that any object that
I create with this function,

100
00:07:11.530 --> 00:07:16.600
sometime later I can add
features to all of those objects

101
00:07:16.600 --> 00:07:22.600
at once by using this .prototype
property of the function constructor.

102
00:07:22.600 --> 00:07:23.850
It's pretty neat right?

103
00:07:23.850 --> 00:07:29.640
If I had created a 1000 different objects
using new person, I could give them all,

104
00:07:29.640 --> 00:07:34.760
in one stroke, access to a new method
later, even after they were created.

105
00:07:35.900 --> 00:07:41.670
So often you'll see, in really good
JavaScript code, that properties

106
00:07:41.670 --> 00:07:46.820
are set up inside the function constructor
because they're often different values.

107
00:07:46.820 --> 00:07:47.910
We need that.

108
00:07:47.910 --> 00:07:50.870
But methods are sitting on the prototype.

109
00:07:52.270 --> 00:07:56.420
So why wouldn't you add
getFullName inside here?

110
00:07:56.420 --> 00:07:59.053
Inside the person object?

111
00:07:59.053 --> 00:08:03.370
You could,
inside that function constructor,

112
00:08:03.370 --> 00:08:07.420
inside that object that this is
pointing to, but here's the problem.

113
00:08:07.420 --> 00:08:10.800
And remember that functions
in JavaScript are objects.

114
00:08:10.800 --> 00:08:13.150
They take up memory space.

115
00:08:13.150 --> 00:08:15.950
Anything you add to them
takes up memory space.

116
00:08:17.210 --> 00:08:21.170
So, if I added getFullName, for example,

117
00:08:21.170 --> 00:08:26.420
to every object,
then that means every object gets its own

118
00:08:26.420 --> 00:08:31.550
copy of getFullName and
takes up more memory space.

119
00:08:31.550 --> 00:08:36.800
If I have 1,000 of these person objects,
I'll have 1,000 getFullName methods.

120
00:08:38.860 --> 00:08:43.230
But if I add it to the prototype,
I'll only have one.

121
00:08:43.230 --> 00:08:46.120
Even though I have 1,000 objects,
I only have this method once.

122
00:08:47.670 --> 00:08:52.670
So, from a efficiency standpoint,
it's better to put your

123
00:08:52.670 --> 00:08:58.100
methods on the prototype because
they only need one copy to be used.

124
00:08:58.100 --> 00:08:58.630
Make sense?

125
00:09:00.170 --> 00:09:02.890
I need my properties for
each object cuz it's going to have

126
00:09:02.890 --> 00:09:06.910
different values per object, but
for methods, I only need one.

127
00:09:08.350 --> 00:09:11.620
And when the object calls that method,

128
00:09:11.620 --> 00:09:16.080
the JavaScript engine will go down the
prototype chain to find it and find it.

129
00:09:16.080 --> 00:09:18.600
I don't need it to be copied over and
over again.

130
00:09:18.600 --> 00:09:24.530
So instead of saying this.getfullName
which would put this on every single

131
00:09:24.530 --> 00:09:30.880
object created, I simply put it on
the prototype, and it'll get found.

132
00:09:30.880 --> 00:09:34.410
I can still use it just like I would
if I had put it directly on the object.

133
00:09:34.410 --> 00:09:35.860
Does that make sense?

134
00:09:35.860 --> 00:09:37.100
I'm saving memory space.

135
00:09:38.710 --> 00:09:43.100
All right, because there's only one
prototype for all of these objects, so

136
00:09:43.100 --> 00:09:44.170
it's only in one spot.

137
00:09:46.020 --> 00:09:49.270
So that's function
constructors in the prototype.

138
00:09:50.370 --> 00:09:55.210
I can create objects, and
the prototype is already set for me.

139
00:09:55.210 --> 00:09:56.690
Then I can just add properties and

140
00:09:56.690 --> 00:10:01.280
methods to the prototype
in order to give all of my

141
00:10:01.280 --> 00:10:06.690
objects that I create with this function
access to those properties and methods.

142
00:10:06.690 --> 00:10:07.830
Make sense?

143
00:10:07.830 --> 00:10:08.420
Think about this.

144
00:10:08.420 --> 00:10:09.060
Give it a try.

145
00:10:09.060 --> 00:10:10.100
Try it out.

146
00:10:10.100 --> 00:10:10.930
Try out the code.

147
00:10:12.210 --> 00:10:16.650
This is how you use functions and function
constructors in setting the prototype.

148
00:10:16.650 --> 00:10:20.840
This is one of the valid
ways to create objects and

149
00:10:20.840 --> 00:10:23.430
set their prototype in JavaScript.

