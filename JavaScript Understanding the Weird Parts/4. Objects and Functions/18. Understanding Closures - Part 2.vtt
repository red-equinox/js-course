WEBVTT

1
00:00:02.878 --> 00:00:07.978
If you research closures online you
will inevitably run across this

2
00:00:07.978 --> 00:00:13.972
example as far as why closures can make
your code look hard to anticipate, but it

3
00:00:13.972 --> 00:00:21.200
actually really isn't that true when you
understand what's going on under the hood.

4
00:00:21.200 --> 00:00:25.410
So we're going to pull up this example,
we'll write it out,

5
00:00:25.410 --> 00:00:30.680
then we'll examine it, and see if we
can't have a clear understanding,

6
00:00:30.680 --> 00:00:35.210
a clear expectation of what's going
to happen when this code is run.

7
00:00:36.678 --> 00:00:38.970
All right, so I'm going to go ahead and

8
00:00:38.970 --> 00:00:41.982
write a new function
called build functions.

9
00:00:41.982 --> 00:00:50.200
And I'm going to create an empty array,
remember that's array literal syntax,

10
00:00:50.200 --> 00:00:54.030
I'm just creating an empty array and
a for loop.

11
00:00:55.310 --> 00:00:58.030
I'm gonna create a variable I,
which is my counter.

12
00:00:59.030 --> 00:01:01.060
As long as it's less
than 3 I'll keep going.

13
00:01:01.060 --> 00:01:06.629
So, I'll do this 3 times,
and then I have my for loop.

14
00:01:08.190 --> 00:01:12.157
Inside my for loop, I'm going to
add something to the array, and

15
00:01:12.157 --> 00:01:15.404
in JavaScript I can use .push,
and that just means,

16
00:01:15.404 --> 00:01:19.760
add this thing I'm about to put inside
these parentheses to the array.

17
00:01:20.930 --> 00:01:24.360
And what I'm going to put
inside the array is a function.

18
00:01:24.360 --> 00:01:30.930
Remember, arrays are functions
of anything and that is that

19
00:01:30.930 --> 00:01:36.360
arrays are collections of anything, so
I can put functions inside of them.

20
00:01:37.680 --> 00:01:44.630
So my function that's going to be put
inside my array is just going to output I,

21
00:01:44.630 --> 00:01:49.199
which is up here up at scope chain,
its outer reference.

22
00:01:51.770 --> 00:01:54.730
So, I'm going to do that three times.

23
00:01:54.730 --> 00:02:00.020
I'm going to add three new function
objects using these function expressions,

24
00:02:00.020 --> 00:02:00.620
to an array.

25
00:02:00.620 --> 00:02:04.680
So, when this is done,
I'll have three functions inside my array.

26
00:02:04.680 --> 00:02:09.090
Equivalent functions, identical functions,
but three different functions,

27
00:02:11.000 --> 00:02:15.795
and this function will
just return that array.

28
00:02:15.795 --> 00:02:17.262
Got it?

29
00:02:17.262 --> 00:02:23.880
All right, so now that we have this,
we see what's going on.

30
00:02:26.060 --> 00:02:29.370
I'll just scroll down a bit here, and

31
00:02:29.370 --> 00:02:35.019
I'm going to get that array
by calling buildfunctions.

32
00:02:36.290 --> 00:02:38.210
So now I have my array in this variable.

33
00:02:39.490 --> 00:02:42.530
And then, remember that these
are functions inside the array, so

34
00:02:42.530 --> 00:02:46.880
I can reference an item, an element
inside the array, the first one,

35
00:02:46.880 --> 00:02:50.230
in this case, and then I'll call it.

36
00:02:51.790 --> 00:02:59.620
And I'm going to do this for all three
functions that are put inside the array

37
00:02:59.620 --> 00:03:03.960
via that for loop, so
let me just back this out a little bit.

38
00:03:05.550 --> 00:03:06.378
Take a good look.

39
00:03:08.461 --> 00:03:15.920
What do you expect this console.log to
output in each of these three cases?

40
00:03:15.920 --> 00:03:18.449
It's outputting i.

41
00:03:20.380 --> 00:03:25.120
Now, you need to remember that
this isn't invoking the function,

42
00:03:25.120 --> 00:03:26.170
it's just creating it.

43
00:03:28.020 --> 00:03:32.250
The function is invoked here, and
then the other function here, and

44
00:03:32.250 --> 00:03:34.040
the other function here.

45
00:03:34.040 --> 00:03:38.780
So, these functions that are being
created here are being invoked down here,

46
00:03:40.170 --> 00:03:42.840
this is just creating them and
putting them in the array.

47
00:03:42.840 --> 00:03:47.051
So, when this function is actually
invoked and it looks at I, and

48
00:03:47.051 --> 00:03:51.032
it looks at its outer reference,
what will I be?

49
00:03:51.032 --> 00:03:57.180
All right so this is one of those
things that tends to surprise people.

50
00:03:57.180 --> 00:04:01.780
When you look at this code,
what you might expect is to see 0, 1, 2.

51
00:04:01.780 --> 00:04:08.366
Is that what you expected?

52
00:04:08.366 --> 00:04:10.698
Or are you expecting something else?

53
00:04:10.698 --> 00:04:13.411
Let's look.

54
00:04:13.411 --> 00:04:18.130
Refresh, I got all threes.

55
00:04:18.130 --> 00:04:21.100
Are you surprised by that?

56
00:04:23.120 --> 00:04:27.120
Why would in every case,
when it looks for i and

57
00:04:27.120 --> 00:04:32.949
goes out to the outer reference,
why would it find a three in all cases?

58
00:04:34.640 --> 00:04:37.860
Well, maybe you've figured this out,
but let's go ahead and

59
00:04:37.860 --> 00:04:40.460
take a good look at what's
happening under the hood.

60
00:04:42.580 --> 00:04:43.660
So here's our code again.

61
00:04:45.020 --> 00:04:50.655
We have buildFunctions that is pushing
these functions into this array,

62
00:04:50.655 --> 00:04:55.445
and then we call those
functions at the bottom.

63
00:04:57.315 --> 00:05:01.145
So we have an array of three
functions at the end of this, and

64
00:05:01.145 --> 00:05:04.105
each of them console.log's the value of i.

65
00:05:04.105 --> 00:05:09.715
And when we ran this, everyone of
those function calls logged three.

66
00:05:11.140 --> 00:05:11.640
So why?

67
00:05:13.030 --> 00:05:17.570
Well, how does the execution stack
look like as this is happening?

68
00:05:18.870 --> 00:05:23.782
Well, the global Execution Context
is always there at the bottom and

69
00:05:23.782 --> 00:05:28.879
it contains the build functions, and
this variable we just called fs.

70
00:05:30.795 --> 00:05:36.670
And so, we hit this line where
it executes buildFunctions().

71
00:05:36.670 --> 00:05:41.312
So, when buildFunctions() executes or
is invoked,

72
00:05:41.312 --> 00:05:46.246
we get an execution context,
and it has two variables, i,

73
00:05:46.246 --> 00:05:49.504
which was created on this for loop, and

74
00:05:49.504 --> 00:05:54.370
arr, which we declared at
the beginning of the function.

75
00:05:56.390 --> 00:06:00.280
But what are the values
of those two variables

76
00:06:00.280 --> 00:06:03.080
by the time we hit the return statement?

77
00:06:04.820 --> 00:06:08.770
Well, the for loop runs, and so,

78
00:06:08.770 --> 00:06:14.090
i is at first 0, and
it pushes the function into the array,

79
00:06:14.090 --> 00:06:17.980
it adds this new function
to the array right here.

80
00:06:19.840 --> 00:06:25.390
But realize that console.log
isn't being executed right here,

81
00:06:25.390 --> 00:06:28.710
and that's where a lot
of people get confused.

82
00:06:28.710 --> 00:06:30.870
But, we already understand
function expressions.

83
00:06:31.890 --> 00:06:35.800
That all that's happening here is I'm
creating a new function object and

84
00:06:35.800 --> 00:06:38.320
putting that line of code
into it's code property.

85
00:06:39.420 --> 00:06:42.980
But it isn't actually running,
it's just creating that object.

86
00:06:42.980 --> 00:06:44.410
I haven't invoked the function.

87
00:06:46.580 --> 00:06:52.630
So it continues, i becomes a 1,
because of the i++.

88
00:06:52.630 --> 00:06:56.210
It adds another function
object into the array,

89
00:06:57.930 --> 00:07:01.560
looks identical but
it's a separate function object.

90
00:07:01.560 --> 00:07:05.870
Then i becomes 2 because of the i++,

91
00:07:05.870 --> 00:07:09.908
and we get a third function
pushed into the array.

92
00:07:09.908 --> 00:07:17.090
Then the i++ is run again, and i is 3, and

93
00:07:17.090 --> 00:07:22.682
the engine sees that i is
less than 3 expression,

94
00:07:22.682 --> 00:07:27.100
and says oh, i is no longer less than 3,
and leaves the for loop.

95
00:07:28.290 --> 00:07:34.880
That's how for loops work,
the i, that variable,

96
00:07:34.880 --> 00:07:40.380
now is larger than my statement
of when to leave the for loop,

97
00:07:41.830 --> 00:07:46.780
so since that's now false,
I leave the for loop,

98
00:07:48.130 --> 00:07:54.200
but realize that i, its last value
when i leave that for loop is now a 3.

99
00:07:54.200 --> 00:07:56.980
That's what told me to leave the for loop.

100
00:07:58.880 --> 00:08:05.260
So when i hit this return arr,
what's in memory

101
00:08:05.260 --> 00:08:09.930
in that execution context,
is that i is a 3,

102
00:08:09.930 --> 00:08:15.780
an array, that arr, holds 3 functions.

103
00:08:15.780 --> 00:08:19.480
We'll just call them f0, f1,
f2, but they're anonymous.

104
00:08:21.750 --> 00:08:26.660
So then, we go back to the global
execution context, and

105
00:08:26.660 --> 00:08:32.620
this buildFunctions execution
context is popped off the stack.

106
00:08:34.990 --> 00:08:36.130
But what have we learned before?

107
00:08:37.790 --> 00:08:40.120
What's in memory is still hanging around.

108
00:08:42.130 --> 00:08:47.460
So now we hit this first function
call where I take the first element

109
00:08:47.460 --> 00:08:51.260
in the array, which is a function,
and execute it.

110
00:08:53.180 --> 00:08:58.070
The code in the code
property is council.log(i),

111
00:08:58.070 --> 00:09:00.840
so its execution context is created.

112
00:09:01.840 --> 00:09:08.870
There is no variable i inside of its code,
so it goes up the scope chain.

113
00:09:10.510 --> 00:09:13.290
It goes to its outer reference.

114
00:09:13.290 --> 00:09:14.340
Where was it created?

115
00:09:14.340 --> 00:09:18.540
Inside build functions, and
what is inside the memory

116
00:09:19.660 --> 00:09:22.828
that used to be in the build
functions execution context.

117
00:09:22.828 --> 00:09:25.599
I is 3.

118
00:09:27.580 --> 00:09:34.200
So it says, all right,
console.log3, and then it finishes.

119
00:09:34.200 --> 00:09:38.330
We move on to the next function,
the next one inside the array,

120
00:09:39.810 --> 00:09:43.830
and an execution context is created, but

121
00:09:43.830 --> 00:09:48.410
that one has the same outer
environment reference,

122
00:09:48.410 --> 00:09:52.130
because it was created in the same
place as the first function.

123
00:09:53.690 --> 00:09:59.080
Physically it's sitting in the same spot,
inside the same build function.

124
00:09:59.080 --> 00:10:02.008
So its outer environment reference,

125
00:10:02.008 --> 00:10:05.720
because of its position
physically in the code,

126
00:10:05.720 --> 00:10:11.080
because of it's left position, is to
the same spot in memory as the first one.

127
00:10:12.320 --> 00:10:16.110
And so when it looks for i,
it looks at that same spot in memory,

128
00:10:17.510 --> 00:10:22.890
where the build functions held
its variables, and sees a three.

129
00:10:22.890 --> 00:10:28.940
So console.log(i) results in a three, and
the same thing for the third function,

130
00:10:30.040 --> 00:10:36.000
they all point at the same memory
spot going up the scope chain

131
00:10:36.000 --> 00:10:40.630
because they were all created inside
the same function, buildFunctions.

132
00:10:41.910 --> 00:10:46.630
So all three of these have
the same parent so to speak.

133
00:10:46.630 --> 00:10:50.280
This would be like three children and
you ask them how old is their father.

134
00:10:51.480 --> 00:10:55.580
They're not gonna tell you how old their
father was when each of them was born.

135
00:10:56.760 --> 00:11:00.460
They're each gonna give you the same
answer, how old their father is now.

136
00:11:02.460 --> 00:11:06.570
In the same way, we have three functions
that are being executed later,

137
00:11:08.300 --> 00:11:12.710
so when we execute the function,
it's only going to be able to tell you

138
00:11:13.890 --> 00:11:18.550
what the value is in memory of its parent

139
00:11:18.550 --> 00:11:22.550
context of that outer
environment reference.

140
00:11:22.550 --> 00:11:26.220
It's only going to be able to tell
you what's in memory right now,

141
00:11:26.220 --> 00:11:28.370
not at the time that we
created the function.

142
00:11:29.540 --> 00:11:32.280
Only right now when we're
actually executing the function.

143
00:11:33.740 --> 00:11:37.070
And so all three output the same thing

144
00:11:38.140 --> 00:11:41.640
because all three are pointing
to that same location in memory.

145
00:11:43.500 --> 00:11:48.300
We're doing exactly what we're
telling the JavaScript engine to do.

146
00:11:50.290 --> 00:11:54.910
At first glance, this may look weird,
but as soon as you realize that,

147
00:11:54.910 --> 00:11:59.470
that console.log isn't executed
right there where it's sitting, but

148
00:11:59.470 --> 00:12:01.730
executed when we invoke these functions.

149
00:12:03.020 --> 00:12:08.183
When we look behind the scenes instead
of looking at purely what we're

150
00:12:08.183 --> 00:12:12.836
writing in the code, this makes sense,
it makes total sense.

151
00:12:14.461 --> 00:12:19.310
The value of I is what it is at
the moment that I execute the function.

152
00:12:21.370 --> 00:12:21.920
Makes sense?

153
00:12:21.920 --> 00:12:26.050
Look at this, look at the code yourself,
write the code out, think about it.

154
00:12:28.060 --> 00:12:32.680
This example that you see all over
the internet isn't really that tough

155
00:12:33.780 --> 00:12:36.450
if you really stop and
ponder it just for a bit.

156
00:12:38.990 --> 00:12:44.000
I is three by the time you
call all these functions, and

157
00:12:44.000 --> 00:12:45.280
so that's what they're going to output.

158
00:12:45.280 --> 00:12:46.512
Got that?

159
00:12:46.512 --> 00:12:52.650
All right, moving on.

160
00:12:52.650 --> 00:12:58.870
We've seen that first class functions
plus this language feature of closures,

161
00:12:58.870 --> 00:13:04.600
where when I execute the function it
still has access to the outer variables.

162
00:13:04.600 --> 00:13:08.040
By the way,
these are also called free variables.

163
00:13:08.040 --> 00:13:12.880
A free variable is a variable
that is outside a function, but

164
00:13:12.880 --> 00:13:13.930
that you have access to.

165
00:13:15.400 --> 00:13:20.280
So it closes in,
it wraps up these variables, and

166
00:13:20.280 --> 00:13:23.890
at the point of execution,
all three of these functions,

167
00:13:23.890 --> 00:13:27.240
because they're sitting in the same spot,
are going to be

168
00:13:27.240 --> 00:13:31.680
pointing to the same memory space where
these outer variables were located.

169
00:13:33.430 --> 00:13:37.040
And you might ask the question,
well what if I did want this to work?

170
00:13:37.040 --> 00:13:41.700
What if I did want this to do
what I just said, to output zero,

171
00:13:41.700 --> 00:13:42.680
then a one, then a two?

172
00:13:42.680 --> 00:13:46.109
Well there's a couple
ways to approach that.

173
00:13:47.890 --> 00:13:50.250
Let's just move ourselves down a bit.

174
00:13:51.570 --> 00:13:56.070
And we'll call this buildFunctions2,
and fs2, just so

175
00:13:56.070 --> 00:13:58.850
we'll have them separate
in the same code here.

176
00:14:00.360 --> 00:14:01.662
And I'll call it buildFunctions2.

177
00:14:01.662 --> 00:14:06.780
All right, what's coming to JavaScript

178
00:14:08.490 --> 00:14:11.960
with esx is that let variable,
remember we said that.

179
00:14:12.960 --> 00:14:18.200
So I could do something like this,
in console.log j.

180
00:14:19.630 --> 00:14:27.270
What happens here will be that
the let variable that's created,

181
00:14:27.270 --> 00:14:32.340
is scoped to the block, so,
inside these curly braces.

182
00:14:32.340 --> 00:14:37.040
So every time the four loop runs,
this will be a new variable in memory.

183
00:14:39.040 --> 00:14:44.190
And it will be segmented in the side
of memory of this execution context so

184
00:14:44.190 --> 00:14:49.393
that when this function is called,
it would be pointing each time

185
00:14:49.393 --> 00:14:54.950
at a different spot within that memory.

186
00:14:54.950 --> 00:15:01.450
These are subsegmented essentially
as separately scoped variables.

187
00:15:01.450 --> 00:15:08.600
So new JavaScript functionality lets us do
it this way, however how could we do it

188
00:15:08.600 --> 00:15:13.410
with the ES5 that is the current
version of JavaScript functionality.

189
00:15:15.270 --> 00:15:20.900
Well, in order to preserve
the value of i for

190
00:15:20.900 --> 00:15:26.280
this function I'm going to
need a separate execution

191
00:15:26.280 --> 00:15:32.700
context for each of the functions
that I'm pushing into the array.

192
00:15:32.700 --> 00:15:40.239
I need a parent scope that holds
the current value of I as the loop goes.

193
00:15:41.980 --> 00:15:46.700
So, the only way to get an execution
context is to execute a function.

194
00:15:47.850 --> 00:15:50.350
So, how can I execute
a function on the fly?

195
00:15:50.350 --> 00:15:51.940
Do you remember?

196
00:15:53.615 --> 00:15:57.555
An immediately invoked function expression
is a nice, clean way to do that.

197
00:15:58.965 --> 00:16:00.305
So I can make a function.

198
00:16:00.305 --> 00:16:04.735
Let's say I give it a variable j.

199
00:16:05.930 --> 00:16:10.310
I'm going to create it and
then execute it, and give it i.

200
00:16:12.210 --> 00:16:18.750
So, now I have an immediately
invoked function expression.

201
00:16:18.750 --> 00:16:22.180
See that?
I had an extra parenthesis there.

202
00:16:22.180 --> 00:16:27.680
I'm going to put this
inside Either one is valid.

203
00:16:29.190 --> 00:16:34.050
And so now I have a function,
and I'm passing i.

204
00:16:34.050 --> 00:16:35.690
So what's going to happen?

205
00:16:35.690 --> 00:16:39.450
Well every time the loop runs,
it's going to execute this function,

206
00:16:40.680 --> 00:16:45.250
passing 0, then it's going to
execute a new one, passing 1,

207
00:16:45.250 --> 00:16:48.130
then it's gonna execute a new one,
passing 2,

208
00:16:48.130 --> 00:16:52.920
and each of those executions creates
its own execution context, and

209
00:16:52.920 --> 00:16:56.770
j will be stored in each of
those three execution contexts.

210
00:16:58.095 --> 00:17:02.605
So I'll have j as zero, and another
execution context where j is one, and

211
00:17:02.605 --> 00:17:06.225
a different execution
context where j is two.

212
00:17:07.335 --> 00:17:10.930
And even though those execution contexts
will go away after this line is run,

213
00:17:10.930 --> 00:17:15.220
we know thanks to closures,
that J, all those three Js for

214
00:17:15.220 --> 00:17:18.660
those three different execution
contexts will be hanging out.

215
00:17:18.660 --> 00:17:26.845
So I can just return function,
console.log(j).

216
00:17:26.845 --> 00:17:29.210
Whoa, that's kinda crazy right?

217
00:17:29.210 --> 00:17:35.450
But look, we're doing a push and

218
00:17:35.450 --> 00:17:39.600
this push is going to push the result
of executing this function

219
00:17:41.820 --> 00:17:45.050
and executing this function
gives us back a function.

220
00:17:46.870 --> 00:17:48.250
See that?

221
00:17:48.250 --> 00:17:52.700
I'm pushing the result of this
function and when this function runs,

222
00:17:52.700 --> 00:17:55.230
it gives me this so
that's what get's pushed into the array.

223
00:17:57.130 --> 00:18:01.070
Then when this gets executed,
and it looks for j,

224
00:18:01.070 --> 00:18:07.420
it doesn't need to go all the way
out up into this for loop.

225
00:18:07.420 --> 00:18:10.560
It'll just go out to
this execution context.

226
00:18:12.080 --> 00:18:15.770
j will store the value at that
moment it was executed in the loop.

227
00:18:18.050 --> 00:18:22.150
So I should see what I originally
thought I was going to see,

228
00:18:22.150 --> 00:18:24.830
and there it is 0, 1, 2.

229
00:18:27.630 --> 00:18:30.830
So that's a way to use
closures to our advantage

230
00:18:32.820 --> 00:18:37.510
to make sure that we have the values
that we need when we execute this

231
00:18:37.510 --> 00:18:42.310
inner most function later on down
here at the bottom of our code.

232
00:18:43.860 --> 00:18:47.560
So, take a good look at this code.

233
00:18:47.560 --> 00:18:48.830
Make sure that you understand it.

234
00:18:49.930 --> 00:18:54.120
We're using all of these things that we've
learned up to this point when it comes to

235
00:18:54.120 --> 00:18:58.939
first class functions, closures,
and all of these ideas.

236
00:19:01.020 --> 00:19:06.253
If you get this,
you're understanding the fundamental

237
00:19:06.253 --> 00:19:10.510
aspect of advanced JavaScript programming.

238
00:19:12.700 --> 00:19:17.180
And function closures can
be useful in other ways.

239
00:19:19.090 --> 00:19:20.190
All right, let's move on.

