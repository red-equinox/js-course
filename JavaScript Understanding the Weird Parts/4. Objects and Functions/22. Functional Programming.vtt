WEBVTT

1
00:00:01.760 --> 00:00:04.610
After all the discussions of
first class functions and

2
00:00:04.610 --> 00:00:08.850
all these other features in JavaScript,
we're ready to discuss one of my

3
00:00:08.850 --> 00:00:13.882
favorite topics when it comes to
the JavaScript programming language.

4
00:00:14.940 --> 00:00:17.580
It's called Functional Programming.

5
00:00:19.360 --> 00:00:25.089
Although JavaScript sounds like it's
related to the Java programming

6
00:00:25.089 --> 00:00:29.870
language and looks like
the C++ C# Java languages a bit.

7
00:00:31.230 --> 00:00:34.940
It really has more in
common in many ways with

8
00:00:34.940 --> 00:00:37.990
other languages called functional
programming languages.

9
00:00:37.990 --> 00:00:40.570
Languages like Lisp or Scheme or ML.

10
00:00:41.730 --> 00:00:46.640
These are languages that have first
class functions like we've talked about.

11
00:00:46.640 --> 00:00:49.290
Functions that behave as objects.

12
00:00:49.290 --> 00:00:52.160
You can pass them as parameters.

13
00:00:52.160 --> 00:00:54.350
You can return them from functions.

14
00:00:55.620 --> 00:01:01.190
And so, having first class functions
in a JavaScript programming language

15
00:01:01.190 --> 00:01:05.310
means that we can implement what's
called functional programming.

16
00:01:05.310 --> 00:01:10.020
Where we think and
code in terms of functions.

17
00:01:11.150 --> 00:01:16.290
This is one of my favorite topics because
it introduces an entirely different way of

18
00:01:16.290 --> 00:01:20.123
thinking and
implementing when programming.

19
00:01:21.585 --> 00:01:24.430
And introduces an approach
that you simply can't

20
00:01:24.430 --> 00:01:28.060
do in other programming languages that
don't have first class functions.

21
00:01:29.420 --> 00:01:35.410
So let's take a look at some examples of
the beauty of functional programming.

22
00:01:35.410 --> 00:01:37.200
We'll start with a simple array.

23
00:01:38.690 --> 00:01:43.922
I'll put a few numeric values in
an array and I'll just log is so

24
00:01:43.922 --> 00:01:47.871
that we can keep track
of what we're doing, and

25
00:01:47.871 --> 00:01:54.117
let's suppose my task here is to create
a new array out of this first array.

26
00:01:54.117 --> 00:01:58.518
So I need to loop over all
of the items in the array.

27
00:01:58.518 --> 00:02:04.288
Let's say array 1.length,
there's a length property,

28
00:02:04.288 --> 00:02:07.791
how big big it is, how long it is, and

29
00:02:07.791 --> 00:02:12.314
I'm going to use the push
property of the method

30
00:02:12.314 --> 00:02:17.990
to let's say double each
value in this first array.

31
00:02:17.990 --> 00:02:22.420
I'm creating a second array that has each

32
00:02:22.420 --> 00:02:27.320
item double the value of its
equivalent item in the first one.

33
00:02:27.320 --> 00:02:34.250
So I loop over each item, and
I push a value that's times 2 of that.

34
00:02:35.340 --> 00:02:38.380
I get 1, 2, 3, and
then my new array is 2, 4, 6.

35
00:02:41.000 --> 00:02:43.860
I had to write of code to do that.

36
00:02:45.210 --> 00:02:49.310
And we know that as programmers, we want
to always minimize how much work we're

37
00:02:49.310 --> 00:02:53.140
doing, how much typing we're doing and
how often we're repeating ourselves.

38
00:02:54.810 --> 00:02:58.360
We tend to put things into
functions in order to do that,

39
00:02:59.420 --> 00:03:04.120
to limit repetition,
we put work into functions.

40
00:03:04.120 --> 00:03:07.810
In programming languages where
functions aren't first class,

41
00:03:07.810 --> 00:03:12.630
there is limitations to how much
you can put into a function,

42
00:03:12.630 --> 00:03:15.960
to how granularly you
can segment your code.

43
00:03:17.180 --> 00:03:21.830
However, with first class functions we
an do something entirely different.

44
00:03:21.830 --> 00:03:24.140
We can head toward functional programming.

45
00:03:25.330 --> 00:03:27.470
So let's say, for example,
I create a new function.

46
00:03:27.470 --> 00:03:30.360
I'm gonna call it mapForEach.

47
00:03:30.360 --> 00:03:33.512
It takes an array and it takes a function.

48
00:03:33.512 --> 00:03:39.130
Remember I'm using first class functions
so I can pass a function object.

49
00:03:39.130 --> 00:03:42.310
Map simply means what we just did here.

50
00:03:42.310 --> 00:03:46.880
I'm going to take one array, do something
to it and get a new array out of it.

51
00:03:48.040 --> 00:03:50.990
I create a very simple mapping function.

52
00:03:50.990 --> 00:03:52.860
I'll do very similarly
to what I did below.

53
00:03:55.910 --> 00:03:59.560
I'll even borrow this for loop here.

54
00:03:59.560 --> 00:04:05.490
I'll just change this to array, so
I'm looping over whatever array is passed.

55
00:04:06.600 --> 00:04:10.200
I'm going to push to the new array, but

56
00:04:10.200 --> 00:04:12.980
here is where my functional
programming comes in.

57
00:04:14.520 --> 00:04:20.000
I'm going to call a function and
pass in that array item.

58
00:04:23.240 --> 00:04:26.060
And then,
this is going to return the new array.

59
00:04:27.450 --> 00:04:28.350
So do you see what I'm doing?

60
00:04:29.450 --> 00:04:32.620
I'm saying,
I'm going to create a new array.

61
00:04:32.620 --> 00:04:34.110
Loop over the array you've given me.

62
00:04:35.590 --> 00:04:39.550
And add to that new array for
every item in the one that you gave me.

63
00:04:41.530 --> 00:04:46.990
Your array item, which is processed by
some function that you also give me.

64
00:04:48.650 --> 00:04:53.410
I've just abstracted
the concept of iterating or

65
00:04:53.410 --> 00:04:57.130
looping over an array,
creating a new array out of it, and

66
00:04:57.130 --> 00:05:01.870
writing some function, whatever function
you want to, against each item.

67
00:05:01.870 --> 00:05:07.240
Take some action against each item,
pass this array item to the function.

68
00:05:07.240 --> 00:05:10.180
And this function should then
return something that it does with

69
00:05:10.180 --> 00:05:11.580
that array item.

70
00:05:11.580 --> 00:05:12.920
And I'll add that to my new array.

71
00:05:14.090 --> 00:05:19.210
If I do that,
then I can take all of this code here

72
00:05:21.515 --> 00:05:25.015
and instead, I can simply call mapForEach.

73
00:05:25.015 --> 00:05:29.185
I'll pass that first array to it and

74
00:05:29.185 --> 00:05:32.857
then I'll create a function
using a function expression.

75
00:05:32.857 --> 00:05:37.017
It needs to accept an item, because that's
what's going to be passed to it, so

76
00:05:37.017 --> 00:05:38.097
I'll just call it item.

77
00:05:39.297 --> 00:05:43.197
And then it needs to return and
then do something to that item.

78
00:05:47.607 --> 00:05:48.907
Do you see what's happening here?

79
00:05:50.987 --> 00:05:56.287
Let's output this, let's go ahead and
run this, and I get the same results.

80
00:05:56.287 --> 00:05:57.407
A doubled array.

81
00:05:58.770 --> 00:06:00.990
But what I did was I
took all of that code,

82
00:06:00.990 --> 00:06:06.560
all of that noise, of the four loop and

83
00:06:06.560 --> 00:06:11.280
creating the new array, and I segmented
that off into its own function.

84
00:06:12.460 --> 00:06:18.050
And then I gave it the work to do
against each item in the array.

85
00:06:20.410 --> 00:06:22.810
This is very powerful.

86
00:06:22.810 --> 00:06:24.280
Think about his for a bit, look at it.

87
00:06:25.530 --> 00:06:26.870
I called a function.

88
00:06:26.870 --> 00:06:30.750
Gave it an array and told it what
to do in each item in the array.

89
00:06:32.600 --> 00:06:37.005
Then this function here
is what's passed in.

90
00:06:38.975 --> 00:06:40.415
And that is what's called,

91
00:06:40.415 --> 00:06:46.175
what's invoked, as the function
is looping across the array.

92
00:06:47.235 --> 00:06:49.657
That means that I could do
something entirely different.

93
00:06:50.937 --> 00:06:54.697
Let's say I have a third
array that I'm gonna fill up.

94
00:06:54.697 --> 00:06:57.397
And I'll give it this initial 1,
2, 3 array.

95
00:06:58.447 --> 00:07:02.837
But, I don't even have to do
mathematical things with this.

96
00:07:02.837 --> 00:07:10.160
I could simply say, tell me, give me
an array that matches up to this original,

97
00:07:11.160 --> 00:07:15.310
but instead tells me if
an item is greater than two.

98
00:07:16.700 --> 00:07:17.680
See that?

99
00:07:17.680 --> 00:07:21.260
I'm using the exact same map for
each call.

100
00:07:21.260 --> 00:07:25.430
And I'm giving a different bit of work and

101
00:07:25.430 --> 00:07:28.680
then returning a Boolean in this case,
true or false.

102
00:07:28.680 --> 00:07:34.090
So, when I output this,
we get false, false, true.

103
00:07:34.090 --> 00:07:36.370
1 is not greater than 2.

104
00:07:36.370 --> 00:07:37.830
2 is not greater than 2.

105
00:07:37.830 --> 00:07:39.140
3 is greater than 2.

106
00:07:40.520 --> 00:07:42.650
So, I get false, false, true.

107
00:07:44.480 --> 00:07:44.980
See that?

108
00:07:46.790 --> 00:07:49.130
I was able then to reuse this map for

109
00:07:49.130 --> 00:07:54.942
each to do entirely different work against
the array simply by passing the function,

110
00:07:54.942 --> 00:07:58.595
passing the work that I wanted
to get done against it.

111
00:07:58.595 --> 00:08:03.773
This is a classic example
of functional programming.

112
00:08:03.773 --> 00:08:08.347
Where I'm using first class
functions to my advantage

113
00:08:08.347 --> 00:08:13.400
to segment my code in even cleaner and
tighter ways.

114
00:08:13.400 --> 00:08:19.920
And this lets me build really clean and
in some ways beautiful looking code.

115
00:08:19.920 --> 00:08:21.700
That's very straightforward to understand.

116
00:08:22.940 --> 00:08:23.920
So mess around with this.

117
00:08:23.920 --> 00:08:29.720
Try creating your own functions
that you pass to the mapForEach.

118
00:08:29.720 --> 00:08:34.010
Or create some other function that
accepts a function that does work.

119
00:08:35.830 --> 00:08:37.190
Let's look at another example.

120
00:08:37.190 --> 00:08:40.458
Let's say,
let me spread this out just a little bit.

121
00:08:40.458 --> 00:08:45.948
Let's say that I'm gonna
use my mapForEach to check

122
00:08:45.948 --> 00:08:50.830
if something is past a limit,
just like here.

123
00:08:50.830 --> 00:08:55.990
But what if I want to make this
two a variable that I pass in,

124
00:08:55.990 --> 00:08:57.420
so that I can make this reusable?

125
00:08:58.420 --> 00:09:03.890
Well, I can do the creation
of a new function.

126
00:09:06.280 --> 00:09:08.690
And maybe I'll pass my limiter,

127
00:09:08.690 --> 00:09:12.190
what it is that I wanna say
that it must be greater than.

128
00:09:14.230 --> 00:09:18.540
Or less than and
it will accept the item as

129
00:09:18.540 --> 00:09:22.560
well because it's gonna do work
against each item in the array.

130
00:09:22.560 --> 00:09:26.870
And I'll return item > limiter.

131
00:09:30.120 --> 00:09:31.600
See that?

132
00:09:31.600 --> 00:09:34.560
So it's past whatever limit,
I passed to it.

133
00:09:34.560 --> 00:09:40.080
I'm just using a variable instead of
directly hard coding a number right there.

134
00:09:40.080 --> 00:09:43.570
I'm saying check and
see if this item is past a certain limit.

135
00:09:45.380 --> 00:09:47.519
All right, so how can I use this?

136
00:09:48.730 --> 00:09:50.210
I have a bit of a problem.

137
00:09:50.210 --> 00:09:54.520
This function accepts two parameters,
and the map for

138
00:09:54.520 --> 00:09:56.630
each wants a function
that accepts just one.

139
00:09:58.590 --> 00:10:01.150
So how can I take a function and
call it, or

140
00:10:01.150 --> 00:10:05.090
use it in a way that I've
preset this parameter.

141
00:10:06.360 --> 00:10:08.820
So that this function call up here

142
00:10:08.820 --> 00:10:12.970
where it passes the item in my
past in array to the function.

143
00:10:14.100 --> 00:10:18.220
So that that get's passed to item and
I would preset this.

144
00:10:18.220 --> 00:10:18.720
Do you remember?

145
00:10:20.870 --> 00:10:22.980
So, I can use bind.

146
00:10:23.980 --> 00:10:30.000
I could say, I'll create another array,
mapForEach, pass on that initial array.

147
00:10:31.070 --> 00:10:34.526
checkPastLimit, but I'll bind.

148
00:10:34.526 --> 00:10:38.960
The this keyword I don't
need to worry about.

149
00:10:38.960 --> 00:10:44.660
So I'll just pass the whatever this
keyword is here, and I'll set 1.

150
00:10:44.660 --> 00:10:47.710
Remember that if I put
parameters on the bind,

151
00:10:47.710 --> 00:10:53.540
it will default that parameter or
preset that parameter to that value.

152
00:10:53.540 --> 00:10:55.800
For every subsequent function call.

153
00:10:57.890 --> 00:11:02.500
So I've just created a copy
of this function on the fly,

154
00:11:02.500 --> 00:11:05.040
with 1 as the limiter.

155
00:11:06.700 --> 00:11:10.850
So now I can just console.log
the resulting array.

156
00:11:12.960 --> 00:11:15.040
So this should return false or

157
00:11:15.040 --> 00:11:19.680
true depending on if each item
in the array is greater than 1.

158
00:11:19.680 --> 00:11:23.310
There it is, 1 is not greater than 1,

159
00:11:23.310 --> 00:11:27.490
2 is greater than 1, 3 is greater than 1.

160
00:11:27.490 --> 00:11:29.740
Do you see that?

161
00:11:31.150 --> 00:11:33.120
That's my resulting array.

162
00:11:33.120 --> 00:11:35.060
Let's track what happened again.

163
00:11:35.060 --> 00:11:42.560
I created a function using a function
expression that accepted some limiter

164
00:11:42.560 --> 00:11:48.380
that I'm checking against to see if my
individual array items are higher than it.

165
00:11:48.380 --> 00:11:52.590
Accepts an item because we need to
do work on each individual item.

166
00:11:52.590 --> 00:11:53.710
And it gives me back a Boolean.

167
00:11:55.300 --> 00:11:58.780
I then call mapForEach,
and I pass the array.

168
00:11:58.780 --> 00:12:00.280
That's the array that it loops over.

169
00:12:01.730 --> 00:12:03.375
And I pass a function.

170
00:12:03.375 --> 00:12:05.560
But I make a copy of it using bind.

171
00:12:07.150 --> 00:12:09.880
I just put this in there because
it doesn't really matter.

172
00:12:09.880 --> 00:12:13.630
I'm not using a this keyword
inside the function, and

173
00:12:13.630 --> 00:12:17.600
then I set this first parameter to a 1.

174
00:12:17.600 --> 00:12:21.930
So that when this mapForEach
calls function and

175
00:12:21.930 --> 00:12:27.740
passes that array item,
that array item will get passed into here.

176
00:12:27.740 --> 00:12:30.000
Cuz this is already a 1,
the limiter is already a 1.

177
00:12:30.000 --> 00:12:36.640
So it will say, all right,
is this array item greater than one?

178
00:12:36.640 --> 00:12:37.960
It give me back true or false.

179
00:12:39.030 --> 00:12:41.400
It mapped one, two, three.

180
00:12:41.400 --> 00:12:44.120
To false, true, true.

181
00:12:44.120 --> 00:12:46.450
I could change this to a two.

182
00:12:46.450 --> 00:12:51.405
It becomes false, false, true.

183
00:12:51.405 --> 00:12:53.760
2 is not greater than 2,
so that becomes false.

184
00:12:55.440 --> 00:12:56.079
Make sense?

185
00:12:57.360 --> 00:12:59.570
And that's all in one line of code.

186
00:12:59.570 --> 00:13:03.880
But you might say well, it's kind of
annoying to call bind all the time.

187
00:13:03.880 --> 00:13:07.760
It would be nice just to pass in
my limiter as the only parameter.

188
00:13:09.310 --> 00:13:10.510
Can you think of a way to do that?

189
00:13:12.790 --> 00:13:17.930
Can we create a function where
I only pass in the limiter

190
00:13:19.350 --> 00:13:23.350
and it gives me back a function like this?

191
00:13:26.010 --> 00:13:28.070
Give that a try, pause the video.

192
00:13:28.070 --> 00:13:32.890
Try to figure out a way to wrap up this

193
00:13:32.890 --> 00:13:36.940
into a function that
just takes the limiter.

194
00:13:36.940 --> 00:13:42.479
So that all I have to do is just call it
and pass whatever my limiting value is,

195
00:13:42.479 --> 00:13:46.300
my top value,
my value that I want to be right there.

196
00:13:47.590 --> 00:13:49.180
Pause the video and try that for yourself.

197
00:13:49.180 --> 00:13:53.540
See if you can come up with a function
that will be even easier to use so

198
00:13:53.540 --> 00:13:56.570
that I don't have to call
.bind manually all the time.

199
00:13:58.760 --> 00:13:59.260
All right, ready?

200
00:14:01.361 --> 00:14:05.625
I'm gonna create,
I'll call it checkPastLimitSimplified.

201
00:14:07.130 --> 00:14:09.220
And it's gonna just take the limiter.

202
00:14:09.220 --> 00:14:13.580
And since it's going to
just take the limiter,

203
00:14:13.580 --> 00:14:19.010
I need to create a function
that I created up here.

204
00:14:19.010 --> 00:14:22.470
So it's going to return a function object.

205
00:14:22.470 --> 00:14:28.380
So I have a function that
returns a function, but

206
00:14:29.610 --> 00:14:36.630
I need it to have its Initial value.

207
00:14:36.630 --> 00:14:42.535
It's first parameter preset.

208
00:14:42.535 --> 00:14:43.639
All right.

209
00:14:43.639 --> 00:14:45.415
Let's take a look at this again.

210
00:14:45.415 --> 00:14:48.110
I have a function that takes the limiter.

211
00:14:49.700 --> 00:14:56.918
It itself returns the function that
I'll actually use, limiter, item.

212
00:14:56.918 --> 00:15:04.020
I use .bind to preset the limiter
from what I was passed here.

213
00:15:06.550 --> 00:15:11.200
So when I run checkPastLimitSimplified,
it will execute,

214
00:15:12.430 --> 00:15:19.332
and it will just give me back a function
that had the bind called on it.

215
00:15:19.332 --> 00:15:24.530
Just like this here, essentially.

216
00:15:26.680 --> 00:15:30.690
Now, don't get confused by this
limiter and this limiter here.

217
00:15:30.690 --> 00:15:33.650
This isn't getting passed to this.

218
00:15:33.650 --> 00:15:35.690
This function isn't being executed.

219
00:15:35.690 --> 00:15:37.730
It's simply creating the function object.

220
00:15:38.960 --> 00:15:41.240
I create it with a function expression.

221
00:15:41.240 --> 00:15:46.890
Then copy that object that was
created with bind with this limiter

222
00:15:46.890 --> 00:15:51.680
perimeter preset to whatever the value
is I passed into that outer function.

223
00:15:52.820 --> 00:15:54.280
So I'm creating an object.

224
00:15:54.280 --> 00:15:56.918
That's all I'm doing,
I'm creating an object.

225
00:15:56.918 --> 00:16:02.361
I'm using .bind to create an object
that has its first parameter preset.

226
00:16:02.361 --> 00:16:07.226
So let's use this,
I'll create yet another array.

227
00:16:07.226 --> 00:16:12.542
MapForEach, pass that first
array that has one, two, three,

228
00:16:12.542 --> 00:16:18.759
and I'll use checkPastLimitSimplified and
I'll simply set my limiter.

229
00:16:22.518 --> 00:16:23.646
Let's log this.

230
00:16:27.953 --> 00:16:30.240
False, false, true.

231
00:16:30.240 --> 00:16:32.630
One is not greater than two.

232
00:16:32.630 --> 00:16:34.630
Two is not greater than two.

233
00:16:34.630 --> 00:16:36.140
Three is greater than two.

234
00:16:38.210 --> 00:16:39.984
Let's change it, I'll just set a one.

235
00:16:43.153 --> 00:16:47.293
One is not greater than one,
two is greater than one,

236
00:16:47.293 --> 00:16:49.411
three is greater than one.

237
00:16:49.411 --> 00:16:50.980
Do you see that?
Do you see what's happening?

238
00:16:52.360 --> 00:16:57.190
I called this function, which returned
a function object with its first

239
00:16:57.190 --> 00:17:02.526
parameter preset to this number,
and that returned

240
00:17:02.526 --> 00:17:08.570
function object is what gets
passed to the map for each.

241
00:17:08.570 --> 00:17:13.606
And then it gets called, and

242
00:17:13.606 --> 00:17:21.112
I get my new array back in one very clean,
very simple line of code that I can reuse.

243
00:17:23.652 --> 00:17:28.089
I hope at this point,
you're taking a good look at this code and

244
00:17:28.089 --> 00:17:33.450
trying this for yourself, that you come
to begin to appreciate the power and

245
00:17:33.450 --> 00:17:37.680
expressiveness of functional programming.

246
00:17:37.680 --> 00:17:42.880
Instead of thinking purely in just
separating your code into functions,

247
00:17:42.880 --> 00:17:47.680
you can start to think about how can
I give my functions, functions, or

248
00:17:47.680 --> 00:17:52.430
return functions from my functions,
in order to even

249
00:17:52.430 --> 00:17:57.220
greater simplify the code that
I'm writing over and over again.

250
00:17:59.060 --> 00:18:02.710
At first, it may feel like it's
stretching your brain a little bit,

251
00:18:02.710 --> 00:18:05.310
to have all these functions flying around.

252
00:18:05.310 --> 00:18:10.175
But once you get used to it,
it's very natural feeling to split

253
00:18:10.175 --> 00:18:14.265
things into functions,
to pass them around to each other,

254
00:18:14.265 --> 00:18:19.085
because you're just splitting
up the work in even finer

255
00:18:19.085 --> 00:18:23.605
more minute granular details than you
might in other programming languages.

256
00:18:25.095 --> 00:18:27.965
And this gives you
an opportunity to really do

257
00:18:28.980 --> 00:18:31.760
some extraordinarily clean things.

258
00:18:32.850 --> 00:18:36.470
One other note about functional
programming, your functions,

259
00:18:37.760 --> 00:18:42.340
especially the tiny ones, as you're moving
and passing little functions around

260
00:18:42.340 --> 00:18:46.470
that do work,
should do their best not mutate data.

261
00:18:47.730 --> 00:18:49.140
Mutate remember, means change.

262
00:18:50.820 --> 00:18:54.625
You can really find yourself in
odd circumstances when you're

263
00:18:54.625 --> 00:18:59.219
actually changing data in these little
tiny functions that you start to pass

264
00:18:59.219 --> 00:19:04.350
around as you're breaking things
down in functional programming.

265
00:19:04.350 --> 00:19:07.720
So it's always better to mutate data,
that is, change it

266
00:19:07.720 --> 00:19:12.180
as high up in that chain as possible of
functions, or to not change it at all.

267
00:19:12.180 --> 00:19:16.280
Instead, return something new,
like we're doing here with

268
00:19:16.280 --> 00:19:20.290
new arrays as opposed to changing
that core array that I passed in.

269
00:19:21.670 --> 00:19:24.520
That's just a side note about
functional programming.

270
00:19:24.520 --> 00:19:28.090
Functional programming in itself
could be an entire course.

271
00:19:28.090 --> 00:19:33.210
But I wanted to introduce you
to this idea in JavaScript

272
00:19:33.210 --> 00:19:36.740
because I think this
first class functions and

273
00:19:36.740 --> 00:19:41.090
functional programming in JavaScript Is
really what takes JavaScript to the next

274
00:19:41.090 --> 00:19:45.610
level, and will take you as a JavaScript
programmer to the next level.

275
00:19:45.610 --> 00:19:51.237
Instead of simply using JavaScript the way
that you use maybe other programming

276
00:19:51.237 --> 00:19:55.772
languages, like PHP or Java or C# or

277
00:19:55.772 --> 00:20:01.100
whatever, you can use the full power of
the language that's available to you.

278
00:20:01.100 --> 00:20:04.987
It's not available in
those other languages.

279
00:20:04.987 --> 00:20:11.482
All right, let's take a moment to talk
about one of the most well used and

280
00:20:11.482 --> 00:20:17.250
well known examples of functional
programming in JavaScript.

